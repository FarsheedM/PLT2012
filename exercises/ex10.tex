\documentclass[a4paper,12pt]{article}

% Use the Classic Thesis style
%
% \usepackage[nochapters]{classicthesis}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

% Use text fonts
%
\usepackage{lmodern}  % the Latin Modern fonts which is an enhanced version of the Computer Modern fonts
% \usepackage{tgschola}  % the Gyre Schola fonts which is an enhanced version of the New Centrury Schoolbook fonts

% Use math fonts
%
% \usepackage{concmath}  % the Concrete Math fonts
% \usepackage{euler}  % the Euler Math fonts
% \usepackage{kerkis}  % the Kerkis fonts

% Some font packages that provide math font may override the text font, the
% following three commands reset it to the default.
%
% For the Latin Modern fonts
%
% \renewcommand{\rmdefault}{lmr}
% \renewcommand{\sfdefault}{lmss}
% \renewcommand{\ttdefault}{lmtt}
%
% For the Gyre Schola fonts
%
% \renewcommand{\rmdefault}{qcs}

\usepackage{amsmath}

% Use the MH bundle
%
% \usepackage{mhsetup}
% \usepackage{mathtools}
% \usepackage{mathstyle}
% \usepackage{breqn}
% \usepackage{empheq}
% \usepackage{flexisym}

% Use AMS-style theorem
%
\usepackage{amsthm}
% \theoremstyle{definition}
% \newtheorem{theorem}{Theorem}

% Use MATH formulas in PARagraph mode Typesetting Inference Rules
% 
\usepackage{mathpartir}

% New commands
%
\newcommand{\term}[1]{\textsf{#1}}

\include{prelude}

% Front elements
%
\title{
 Programming Languages and Types \\~\\
 \textbf{Exercise 10}
}
\author{
 Yi Dai
}

\begin{document}

\maketitle

\section{Abstract Syntax vs. Concrete Syntax}

\subsection{Specification vs. Identification}

The grammar

\begin{grammar}
 \prodhead{(expression)}{$Exp$}{::=}{$Int$}{(number)}
 \prodrule{|}{$Exp\ Opr\ Exp$}{(compound)}
 \\
 \prodhead{(operator)}{$Opr$}{::=}{$+$}{(plus)}
 \prodrule{|}{$-$}{(munus)}
 \prodrule{|}{$*$}{(times)}
 \prodrule{|}{$/$}{(divides)}
\end{grammar}

\noindent
for \emph{specification} vs. the grammar

\begin{grammar}
 \prodhead{(level-0 expression)}{$Exp$}{::=}{$Exp1$}{(level-1 expression)}
 \prodrule{|}{$Exp\ LOp\ Exp1$}{(compound level 1)}
 \\
 \prodhead{(level-1 expression)}{$Exp1$}{::=}{$Exp2$}{(level-2 expression)}
 \prodrule{|}{$Exp1\ HOp\ Exp2$}{(compound level 2)}
 \\
 \prodhead{(level-2 expression)}{$Exp2$}{::=}{$Int$}{(number)}
 \prodrule{|}{$\inparens{\ Exp\ }$}{(parenthesized)}
 \\
 \prodhead{(lower operator)}{$LOp$}{::=}{$+$}{(plus)}
 \prodrule{|}{$-$}{(munus)}
 \\
 \prodhead{(lower operator)}{$LOp$}{::=}{$*$}{(times)}
 \prodrule{|}{$/$}{(divides)}
\end{grammar}

\noindent
for \emph{identification}.

Note that the levels in the second grammar indicates the \emph{priorities}.  Thus
level-0 expressions have the \emph{lowest} priority while level-2 expressions have
the \emph{highest} priority.

\subsection{Theoretical Formulation}

The grammar

\begin{gather*}
 e \in Exp \\
 n \in Int \\
 o \in Opr
\end{gather*}

\begin{grammar}
 \prodhead{(expression)}{$e$}{::=}{$n$}{(number)}
 \prodrule{|}{$e_1\ o\ e_2$}{(compound)}
 \\
 \prodhead{(operator)}{$o$}{::=}{$+$}{(plus)}
 \prodrule{|}{$-$}{(munus)}
 \prodrule{|}{$*$}{(times)}
 \prodrule{|}{$/$}{(divides)}
\end{grammar}

\noindent
widely used in theoretical work is only \emph{semi-abstract}.

\subsection{Abstractness vs. Concreteness}

A \emph{fully} abstract syntax renders the \emph{tree structure} of the expressions
using constructors.

\begin{grammar}
 \prodhead{(expression)}{$Exp$}{::=}{$Num(Int)$}{(number)}
 \prodrule{|}{$Cpd(Opr, Exp, Exp)$}{(compound)}
\end{grammar}

\noindent
Such a description can be readily translated into representations in a language that
supports \textsf{algebraic data types}, like Scala.

\begin{verbatim}
sealed abstract class Exp

type Opr = String

case class Num(int : Int) extends Exp
case class Cpd(opr : Opr, lhs : Exp, rhs : Exp) extends Exp
\end{verbatim}

Once the abstract syntax for a language is given, its concrete syntax can be freely
chosen.  It can be \term{prefix notation}, \term{infix notation}, \term{postfix
notation}, even English, etc.

\section{Inductive Definitions and Rule Induction}

\subsection{Inductive Definitions}

\begin{enumerate}
 \item Inductively-defined sets: natural numbers, arithmetic expressions, etc.
  \begin{mathpar}
   \inferrule
    {n \in Int}
    {n \in Exp}\ \textsc{Num} \qquad
   \inferrule
    {e_1 \in Exp \and e_2 \in Exp \and o \in Opr}
    {e_1\ o\ e_2 \in Exp}\ \textsc{Cpd}
  \end{mathpar}

 \item Inductively-defined relations: $m\ Div\ n$, evaluation relation of
  arithmetic expressions, etc.
  \begin{mathpar}
   \inferrule
    { }
    {m\ Div\ 0}\ \textsc{Zero} \qquad
   \inferrule
    {m\ Div\ n}
    {m\ Div\ n + m}\ \textsc{DSum}
  \end{mathpar}
\end{enumerate}

\noindent
Note that a relation is just a set of tuples.  Hence $m\ Div\ n$ is essentially an
inductively-defined set of pairs $\inparens{m, n}$.

\subsection{Rule Induction}

Rule induction rules!  For every \emph{sound} inductive definition, we have a
\term{rule induction} principle for free.  The notion is simple, to prove some
property $P$ for every element of an inductively defined set, it is sufficient to
prove $P$ holds for the conclusion assuming $P$ holds for all the premises, for
every rule in the inductive definition.  That is, for every rule of the form

\begin{mathpar}
 \inferrule
  {premise_1 \and \ldots \and premise_n}
  {conclusion},
\end{mathpar}

\noindent
prove $P\inparens{conclusion}$ assuming $P\inparens{premise_1}$, $\ldots$,
$P\inparens{premise_n}$, for every $n \in \mathbf{N}$.  When $n = 0$, a rule
becomes an axiom.  In this case, you have to prove $P(conclusion)$ ``out of thin
air''.

\begin{enumerate}
 \item Prove that the sum of the first $n$ natural numbers is
  $\frac{n\inparens{n + 1}}{2}$, that is, prove
  \[ \sum_{n \in \mathbf{N}} n = \frac{n\inparens{n + 1}}{2} \]
 \item Prove that $m\ Div\ n_1$ and $m\ Div\ n_2$ implies $m\ Div\ (n_1 + n_2)$.
  \begin{proof}
   We prove the property
   \[
     P\inparens{m\ Div\ n_1} = \inbracks{\forall n_2 \in \mathbf{N}, m\ Div\ n_2\
     \text{implies}\ m\ Div\ (n_1 + n_2)}
   \]
   for every $m\ Div\ n_1$ by rule induction on $m\ Div\ n_1$.

   \begin{itemize}
    \item Base case: for $\inferrule{ }{m\ Div\ 0}$, we want to prove
     \[
       P\inparens{m\ Div\ 0} = \inbracks{\forall n_2 \in \mathbf{N}, m\ Div\ n_2\
       \text{implies}\ m\ Div\ (0 + n_2)}
     \]

     Since $0 + n_2 = n_2$, the goal is to prove $m\ Div\ n_2$ implies $m\ Div\ n_2$,
     which is trivial.
    \item Inductive case: for $\inferrule{m\ Div\ n_1}{m\ Div\ n_1 + m}$, we want to
     prove
     \begin{multline*}
      P\inparens{m\ Div\ \inparens{n_1 + m}} = \\ \inbracks{\forall n_2 \in \mathbf{N},
       m\ Div\ n_2\ \text{implies}\ m\ Div\ (n_1 + m + n_2)},
     \end{multline*}
     assuming the inductive hypothesis
     \begin{multline*}
      P\inparens{m\ Div\ n_1} = \\ \inbracks{\forall n_2 \in \mathbf{N}, m\ Div\ n_2\
      \text{implies}\ m\ Div\ (n_1 + m)},
     \end{multline*}

     Suppose $\forall n_2 \in \mathbf{N}, m\ Div\ n_2$, by the inductive hypothesis,
     we have $m\ Div\ \inparens{n_1 + n_2}$, then apply the rule \textsc{DSum} by
     instantiating $n$ with $\inparens{n_1 + n_2 + m}$, we can conclude $m\ Div\
     \inparens{m\ Div\ n_1 + n_2 + m}$, that is,
     \begin{mathpar}
      $\inferrule{m\ Div\ \inparens{n_1 + n_2}}{m\ Div\ \inparens{n_1 + n_2 + m}}\
       \textsc{DSum}.
     \end{mathpar}
     Further, from $m\ Div\ \inparens{n_1 + n_2 + m}$, by associativity and commutativity 
     of $+$, we can derive $m\ Div\ \inparens{n_1 + m + n_2}$, which is exactly what we 
     want to prove.
   \end{itemize}
   Therefore, we have proved $P\inparens{m\ Div\ n_1}$ for every $m\ Div\ n_1$, that is,
   $\forall m, n_1, n_2 \in \mathbf{N}, m\ Div\ n_1$ and $m\ Div\ n_2$ implies $m\ Div\
   (n_1 + n_2)$.
  \end{proof}
\end{enumerate}

\section{Evaluation Semantics vs. Reduction Semantics}

\begin{enumerate}
 \item Give the \term{(structural) evaluation semantics} (aka. \term{(structural)
  big-step (operational) semantics}, \term{natural semantics}) for arithmetic expressions.

  We first define a syntactic category for values. For convenience, we integrate it into
  the semi-abstract syntax given above for arithmetic expressions. Hereby we have the
  following syntax definition:
  \begin{gather*}
   e \in Exp \\
   n \in Int \\
   o \in Opr \\
   v \in Val
  \end{gather*}

  \begin{grammar}
   \prodhead{(expression)}{$e$}{::=}{$v$}{(value)}
   \prodrule{|}{$e_1\ o\ e_2$}{(compound)}
   \\
   \prodhead{(operator)}{$o$}{::=}{$+$}{(plus)}
   \prodrule{|}{$-$}{(munus)}
   \prodrule{|}{$*$}{(times)}
   \prodrule{|}{$/$}{(divides)}
   \\
   \prodhead{(value)}{$v$}{::=}{$n$}{(number)}
  \end{grammar}
  
  The evaluation semantics for arithmetic expressions is given by a evaluation relation
  between expressions and values (the final form of expressions after a series of
  reductions), notated as $e \Longrightarrow v$, inductively defined as follows:
  \begin{mathpar}
   \inferrule
    { }
    {v \Longrightarrow v}\ \textsc{EvV} \qquad
   \inferrule
    {e_1 \Longrightarrow v_1 \and e_2 \Longrightarrow v_2}
    {e_1\ o\ e_2 \Longrightarrow op\inparens{o, v_1, v_2}}\ \textsc{EvC}
  \end{mathpar}
  The inductive definition contains two rules, one axiom named \textsc{EvV}, one named
  \textsc{EvC} with two premises. The axiom \textsc{EvV} essentially says that a value
  evaluates to itself. In this example, a value can only be a number. The rule
  \textsc{EvC} says, to obtain the value of a compound expression $e_1\ o\ e_2$, evaluate
  $e_1$ to $v_1$ and $e_2$ to $v_2$, then use a primitive operation corresponding to the
  operator $o$ to get the value of the whole expression from the two values $v_1$ and $v_2$.
  Note that for simple arithmetic expressions, the order of the two premises does not
  matter since the evaluation of the two sub-expressions are independent of each other.

  These rules should remind you of the interpreter you have crafted for arithmetic
  expressions.

  Here is a demonstration of how to apply these evaluation rules to obtain the value of an
  example expression: $1 + 2 * 3 - 4$. Note that we assume the meta-function $op$ can
  handle the operators $+$, $*$ and $-$ correctly.
  {\footnotesize
  \begin{mathpar}
   \inferrule
    {\inferrule
      {\inferrule
        { }
        {1 \Longrightarrow 1}\ \textsc{EvV}
       \and
       \inferrule
        {\inferrule
          { }
          {2 \Longrightarrow 2}\ \textsc{EvV}
         \and
         \inferrule
          { }
          {3 \Longrightarrow 3}\ \textsc{EvV} }
        {2 * 3 \Longrightarrow op\inparens{*, 2, 3} = 6}\ \textsc{EvC} }
      {1 + 2 * 3 \Longrightarrow op\inparens{+, 1, 6} = 7}\ \textsc{EvC}
     \and
     \inferrule
      { }
      {4 \Longrightarrow 4}\ \textsc{EvV} }
    {1 + 2 * 3 - 4 \Longrightarrow op\inparens{-, 7, 4} = 3}\ \textsc{EvC}
  \end{mathpar} }
  So we know the value of the expression $1 + 2 * 3$ is $7$.

 \item Compare evaluation semantics and \term{(structural) reduction semantics} (aka.
  \term{(structural) small-step (operational) semantics}).

  The reduction semantics for arithmetic expressions is given by a reduction relation
  between expressions, notated as $e \longrightarrow e'$, inductively defined as follows:
  \begin{mathpar}
   \inferrule
    { }
    {v_1\ o\ v_2 \longrightarrow op\inparens{o, v_1, v_2}}\ \textsc{Red} \\
   \inferrule
    {e_1 \longrightarrow e_1'}
    {e_1\ o\ e_2 \longrightarrow e_1'\ o\ e_2}\ \textsc{RdL}
   \qquad
   \inferrule
    {e_2 \longrightarrow e_2'}
    {e_1\ o\ e_2 \longrightarrow e_1\ o\ e_2'}\ \textsc{RdR}
  \end{mathpar}
  The axiom \textsc{Red} says that we can invoke the primitve operation corresponding to
  the operator $o$ only when both its operands have reduced to values. The rule \textsc{RdL}
  covers one-step reduction of the left operand of a compound expression, while the rule
  \textsc{RdR} covers that of the right operand. Note that there is no longer a rule like
  $v \longrightarrow v$, since a value cannot be reduced in one step to anything. If such a
  rule is included in the definition, after an expression is reduced to a value, one can
  keep reducing it to itself by applying this rule till the end of the world (Who knows
  when it is, maybe Maya people?).

  Here is a demonstration of how to apply these reduction rules to obtain the final result
  the same expression $1 + 2 * 3 - 4$. Again, we assume the correctness of the
  meta-function $op$.
  \begin{mathpar}
   \inferrule
    {\inferrule
      {\inferrule
        { }
        {2 * 3 \longrightarrow op\inparens{*, 2, 3} = 6}\ \textsc{Red} }
      {1 + 2 * 3 \longrightarrow 1 + 6}\ \textsc{RdR} }
    {1 + 2 * 3 - 4 \longrightarrow 1 + 6 - 4}\ \textsc{RdL}
  \end{mathpar}
  This is just one-step reduction. To reach the final result of the expression, we need
  continue reducing the result expression $1 + 6 - 4$:
  \begin{mathpar}
   \inferrule
    {\inferrule
      { }
      {1 + 6 \longrightarrow op\inparens{+, 1, 6} = 7}\ \textsc{Red} }
    {1 + 6 - 4 \longrightarrow 7 - 4}\ \textsc{RdL}
  \end{mathpar}
  Go on reducing $7 - 4$:
  \begin{mathpar}
   \inferrule
    { }
    {7 - 4 \longrightarrow 3}\ \textsc{Red}
  \end{mathpar}
  Now that the number $3$ can no longer be reduced, it is the result of the whole
  expression. So we have seen that the original expression $1 + 2 * 3 - 4$ is reduced by
  \emph{three} steps to the number $3$, that is,
  \[
    1 + 2 * 3 - 4 \longrightarrow 1 + 6 - 4 \longrightarrow 7 - 4 \longrightarrow 3
  \]
  Note that the number of reduction steps is clearly indicated by the number of occurrences
  of the rule \textsc{Red} in the three derivation trees.
\end{enumerate}

\end{document}

