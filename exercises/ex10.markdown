#Exercise 10#

##Abstract Syntax vs. Concrete Syntax##

###Specification vs. Identification###

```
Exp ::= Int | Exp Opr Exp
Opr ::= + | - | * | /
```

vs.

```
Exp  ::= Exp1 | Exp LOp Exp1
Exp1 ::= Exp2 | Exp1 HOp Exp2
Exp2 ::= Int | ( Exp )

LOp ::= + | -
HOp ::= * | /
```

###Theoretical Formulation###

```
e (- Exp
n (- Int
o (- Opr

e ::= n | e1 o e2
o ::= + | - | * | /
```

Is it abstract?

###Abstract vs. Concrete###

```
Exp ::= Num(Int)
      | Cpd(Opr, Exp, Exp)
```

or

```scala
sealed abstract class Exp

type Opr = String

case class Num(int : Int) extends Exp
case class Cpd(opr : Opr, lhs : Exp, rhs : Exp) extends Exp
```

vs.

Prefix notation, infix notation, postfix notation, English, German, etc.

##Inductive Definitions and Rule Induction##

###Inductive Definitions###

Inductively defined sets: natural numbers, arithmetic expressions

Inductively defined relations: *m Div n*, evaluation relation of arithmetic
expressions

###Rule Induction###

Rule induction rules!

1. Prove that the sum of the first *n* natural numbers is _n \* (n + 1) / 2_.

2. Prove that *m Div n1* and *m Div n2* implies *m Div (n1 + n2)*.

```
Proof

  of P(m Div n1) = [for every n2 (- N, m Div n2 implies m Div (n1 + n2)] for
  every m Div n1, by rule induction on m Div n1

- Base case: for ---------, we want to prove P(m Div 0) = [for every n2 (- N,
                  m Div 0

  m Div n2 implies m Div (0 + n2)].

  Since 0 + n2 = n2, essentially we want to prove m Div n2 assuming m Div n2,
  which is trivial.

                          m Div n1
- Inductive case: for ----------------, we want to prove P(m Div (n1 + m)) = [
                       m Div (n1 + m)

  for every n2 (- N, m Div n2 implies m Div (n1 + m + n2)], assuming the
  inductive hypothesis P(m Div n1) = [for every n2 (- N, m Div n2 implies m
  Div (n1 + n2)].

  Suppose for every n2 (- N, m Div n2, then by the inductive hypothesis, we

                                                m Div n 
  have m Div (n1 + n2), then apply the rule --------------- by instantiating n
                                             m Div (n + m)

  with (n1 + n2), we can conclude m Div (n1 + n2 + m).  That is,

     m Div (n1 + n2)
  ---------------------.  Further, by associativity and commutativity of +,
   m Div (n1 + n2 + m)

  from m Div (n1 + n2 + m), we have m Div (n1 + m + n2), which is exactly what
  we want to prove.

Therefore, we have proved P(m Div n1) for every m Div n1, that is, for every
m, n1, n2 (- N, m Div n1 and m Div n2 implies m Div (n1 + n2).
```

##Evaluation Semantics vs Reduction Semantics##

1. Give the **(structural) evaluation semantics** (aka. **(structural) big-step
(operational) semantics**, **natural semantics**) for arithmetic expressions.

2. Compare evaluation semantics and **(structural) reduction semantics** (aka.
**(structural) small-step (operational) semantics**.

3. Prove that the evaluation semantics coincides with the multi-step reduction
semantics.

