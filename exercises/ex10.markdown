#Exercise 10#

##Abstract Syntax vs. Concrete Syntax##

###Specification vs. Identification###

```
Exp ::= Int | Exp Opr Exp
Opr ::= + | - | * | /
```

vs.

```
Exp  ::= Exp1 | Exp LOp Exp1
Exp1 ::= Exp2 | Exp1 HOp Exp2
Exp2 ::= Int | ( Exp )

LOp ::= + | -
HOp ::= * | /
```

###Theoretical Formulation###

```
e (- Exp
n (- Int
o (- Opr

e ::= n | e1 o e2
o ::= + | - | * | /
```

Is it abstract?

###Abstract vs. Concrete###

```
Exp ::= Num(Int)
      | Cpd(Opr, Exp, Exp)
```

or

```scala
sealed abstract class Exp

type Opr = String

case class Num(int : Int) extends Exp
case class Cpd(opr : Opr, lhs : Exp, rhs : Exp) extends Exp
```

vs.

Prefix notation, infix notation, postfix notation, English, German, etc.

##Inductive Definitions and Rule Induction##

###Inductive Definitions###

1. Inductively defined sets: natural numbers, arithmetic expressions

2. Inductively defined relations: *m Div n*, evaluation relation of arithmetic
   expressions

###Rule Induction###

Rule induction rules!

1. Prove that the sum of the first *n* natural numbers is _n \* (n + 1) / 2_.

2. Prove that *m Div n1* and *m Div n2* implies *m Div (n1 + n2)*.

```
Proof

  of P(m Div n1) = [for every n2 (- N, m Div n2 implies m Div (n1 + n2)] for
  every m Div n1, by rule induction on m Div n1

- Base case: for ---------, we want to prove P(m Div 0) = [for every n2 (- N,
                  m Div 0

  m Div n2 implies m Div (0 + n2)].

  Since 0 + n2 = n2, essentially we want to prove m Div n2 assuming m Div n2,
  which is trivial.

                          m Div n1
- Inductive case: for ----------------, we want to prove P(m Div (n1 + m)) = [
                       m Div (n1 + m)

  for every n2 (- N, m Div n2 implies m Div (n1 + m + n2)], assuming the
  inductive hypothesis P(m Div n1) = [for every n2 (- N, m Div n2 implies m
  Div (n1 + n2)].

  Suppose for every n2 (- N, m Div n2, then by the inductive hypothesis, we

                                                m Div n 
  have m Div (n1 + n2), then apply the rule --------------- by instantiating n
                                             m Div (n + m)

  with (n1 + n2), we can conclude m Div (n1 + n2 + m).  That is,

     m Div (n1 + n2)
  ---------------------.  Further, by associativity and commutativity of +,
   m Div (n1 + n2 + m)

  from m Div (n1 + n2 + m), we have m Div (n1 + m + n2), which is exactly what
  we want to prove.

Therefore, we have proved P(m Div n1) for every m Div n1, that is, for every
m, n1, n2 (- N, m Div n1 and m Div n2 implies m Div (n1 + n2).
```

##Evaluation Semantics vs Reduction Semantics##

1. Give the **(structural) evaluation semantics** (aka. **(structural)
   big-step (operational) semantics**, **natural semantics**) for arithmetic
   expressions.

   We first define a syntactic category for *values*.  For convenience, we
   integrate it into the semi-abstract syntax given above for arithmetic
   expressions.  Hereby we have the following syntax definition:

```
e (- Exp
n (- Int
o (- Opr
v (- Val

e ::= v | e1 o e2
o ::= + | - | * | /

v ::= n
```

   The evaluation semantics for arithmetic expressions is given by a
   evaluation relation between expressions and values (the final form of
   expressions after a series of reductions), notated as `e ===> v`,
   inductively defined as follows:

```
---------- Num
 v ===> v

 e1 ===> v1
 e2 ===> v2
---------------------------- Cpd
 e1 o e2 ===> op(o, v1, v2)
```

   The inductive definition contains two rules, one named **Num** without any
   premise (a so-called **axiom**), one named **Cpd** with two premises.  The
   axiom **Num** essentially says that a value evaluates to itself.  In this
   example, a value can only be a number.  The rule **Cpd** says, to obtain
   the value of the compound expression `e1 o e2`, evaluate `e1` to `v1` and
   `e2` to `v2`, then use a primitive operation corresponding to the operator
   `o` to get the value of the whole expression from the two values `v1` and
   `v2`.  Note that for simple arithmetic expressions, the order of the two
   premises does not matter since the evaluation of the two sub-expressions
   are independent.

   These rules should remind you of the interpreter you have crafted for
   arithmetic expressions.

   Here is a demonstration of how to apply these evaluation rules to obtain
   the value of an example expression: `1 + 2 * 3 - 4`.  Note that we assume
   the meta-function `op` can handle the operator `*` and `+` correctly.

```
                ---------- Num  ---------- Num
                 2 ===> 2        3 ===> 3
---------- Num  ----------------------------Cpd
 1 ===> 1        2 * 3 ===> op(*, 2, 3) = 6
-------------------------------------------- Cpd  ---------- Num
 1 + 2 * 3 ===> op(+, 1, 6) = 7                    4 ===> 4
------------------------------------------------------------ Cpd
       1 + 2 * 3 - 4 ===> op(+, 7, 4) = 3
```

   So we know the value of the expression `1 + 2 * 3` is `7`.

2. Compare evaluation semantics and **(structural) reduction semantics** (aka.
   **(structural) small-step (operational) semantics**.

   The reduction semantics for arithmetic expressions is given by a reduction
   relation between expressions, notated as `e ---> e'`, inductively defined
   as follows:

```
---------------------------- Red
 v1 o v2 ---> op(o, v1, v2)

 e1 ---> e1'
----------------------- RdL
 e1 o e2 ---> e1' o e2

 e2 ---> e2'
----------------------- RdR
 e1 o e2 ---> e1 o e2'
```
 
   The axiom **Red** says that we can invoke the primitve operation
   corresponding to the operator `o` only when both its operands have reduced
   to values.  The rule **RdL** covers one-step reduction of the left operand
   of a compound expression, while the rule **RdR** covers that of the right
   operand.  Note that there is no longer a rule like `v ---> v`, since a
   value cannot be reduced in *one step* to anything.  If such a rule is
   included in the definition, after an expression is reduced to a value, one
   can keep reducing it to itself by applying this rule till the end of the
   world (Who knows when it is, maybe Maya people?).
 
   Here is a demonstration of how to apply these reduction rules to obtain the
   final result the same expression `1 + 2 * 3 - 4`.  Again, we assume the
   correctness of the meta-function `op`.
 
```
---------------------------- Red
 2 * 3 ---> op(*, 2, 3) = 6
---------------------------- RdR
 1 + 2 * 3 ---> 1 + 6
------------------------------ RdL
 1 + 2 * 3 - 4 ---> 1 + 6 - 4
```
 
   This is just one-step reduction.  To reach the final result of the
   expression, we need continue reducing the result expression `1 + 6 - 4`:
 
```
---------------------------- Red
 1 + 6 ---> op(+, 1, 6) = 7
---------------------------- RdL
 1 + 6 - 4 ---> 7 - 4
```
 
   Go on reducing `7 - 4`:
 
```
---------------------------- Red
 7 - 4 ---> op(-, 7, 4) = 3
```
 
   Now that the number `3` can no longer be reduced, it is the result of the
   whole expression.  So we have seen that the original expression `1 + 2 * 3
   - 4* is reduced by *three* steps to the number `3`, that is:

```
1 + 2 * 3 - 4 ---> 1 + 6 - 4 ---> 7 - 4 ---> 3
```
 
   Note that the number of reduction steps is clearly indicated by the number
   of occurences of the rule **Red** in the three derivation trees.

3. Prove that the evaluation semantics coincides with the multi-step reduction
   semantics.

