#Exercise Session 10#

##Abstract Syntax vs. Concrete Syntax##

###Specification vs. Identification###

```
Exp ::= Int | Exp Opr Exp
Opr ::= + | - | * | /
```

vs.

```
Exp  ::= Exp1 | Exp LOp Exp1
Exp1 ::= Exp2 | Exp1 HOp Exp2
Exp2 ::= Int | ( Exp )

LOp ::= + | -
HOp ::= * | /
```

###Theoretical Formulation###

```
e (- Exp
n (- Int

e ::= n | e1 + e2 | e1 - e2 | e1 * e2 | e1 / e2
```

Is it abstract?

###Abstract vs. Concrete###

```
Exp ::= Num(Int)
      | Add(Exp, Exp)
      | Sub(Exp, Exp)
      | Mul(Exp, Exp)
      | Div(Exp, Exp)
```

and in Scala

```scala
sealed abstract class Exp

case class Add(lhs : Exp, rhs : Exp) extends Exp
case class Sub(lhs : Exp, rhs : Exp) extends Exp
case class Mul(lhs : Exp, rhs : Exp) extends Exp
case class Div(lhs : Exp, rhs : Exp) extends Exp
```
vs.

Prefix notation, infix notation, postfix notation, English, etc.

##Rule Induction##

###Inductive Definitions###

Inductively defined sets: natural numbers, arithmetic expressions

Inductively defined relations: m div n, evaluation relation of arithmetic
expressions

###Rule Induction###

Rule induction rules!

##(Structural) Evaluation Semantics##

Give the **(structural) evaluation semantics** (aka. **big-step semantics**,
**natural semantics**) for arithmetic expressions.

